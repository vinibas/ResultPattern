using Microsoft.AspNetCore.Http.HttpResults;
using Microsoft.AspNetCore.Mvc;
using ViniBas.ResultPattern.AspNet.ResultMinimal;
using ViniBas.ResultPattern.DemoWebApi.Services;
using ViniBas.ResultPattern.ResultObjects;

namespace ViniBas.ResultPattern.DemoWebApi.Endpoints;

public static class MinimalApiExtensions
{
    public static void RegisterUserEndpoints(this IEndpointRouteBuilder routes)
    {
        var group = routes.MapGroup("minimal");

        // You can call Match, which will return an IResult, passing only the function 
        // for the success case, and the failure will be a ProblemDetails
        group.MapGet("{value}", (int value, IMyService myService)
            => myService.Get(value).Match(Results.Ok));

        // Or you can call a Match<>, passing the return type, usually a Results<>, generated by TypedResults
        group.MapPost("{value}", (int value, IMyService myService)
            => myService.Post(value).Match<Results<Created, ProblemHttpResult>, Created>(_ => TypedResults.Created()));

        // The same, but for cases where Result<T> has data
        group.MapPut("{value}", (int value, IMyService myService)
            => myService.Custom(value).Match<IResult, Accepted<object>>(v => TypedResults.Accepted($"/minimal/{value}", v)));

        // Or you can directly return a Result, and let the ActionFilter automatically convert 
        // it to a ResultRespondeSuccess on success, or a ProblemDetails on error.
        group.MapDelete("{success}", (bool success, IMyService myService)
            => success ?
            Result<string>.Success("Deleted successfully") :
            Result<string>.Failure(Error.Failure("Err1", "Value must be true")))
            .WithResultsResultFilter();
    }
}