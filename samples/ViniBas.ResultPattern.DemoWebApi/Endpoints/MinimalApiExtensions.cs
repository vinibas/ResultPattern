using Microsoft.AspNetCore.Http.HttpResults;
using ViniBas.ResultPattern.AspNet.ResultMinimal;
using ViniBas.ResultPattern.DemoWebApi.Services;
using ViniBas.ResultPattern.ResultObjects;
using ViniBas.ResultPattern.ResultResponses;

namespace ViniBas.ResultPattern.DemoWebApi.Endpoints;

public static class MinimalApiExtensions
{
    public static void RegisterUserEndpoints(this IEndpointRouteBuilder routes)
    {
        var group = routes.MapGroup("minimal");

        // You can call Match, which will return an IResult, passing the functions to be called on success or failure.
        group.MapGet("{value}", (int value, IMyService myService)
            => myService.Get(value).Match(Results.Ok, TypedResults.Conflict));

        // Or you can call a Match<>, passing the return type, usually a Results<>, generated by TypedResults.
        // If you don't pass a failure function, a ProblemDetails with the failure mapped will be returned.
        group.MapPost("{value}", (int value, IMyService myService)
            => myService.Post(value).Match<Results<Created, ProblemHttpResult>, Created>(_ => TypedResults.Created()));

        // The same, but for cases where Result<T> has data, and passing a function in case of failure
        group.MapPut("{value}", (int value, IMyService myService)
            => myService.Custom(value).Match<IResult, Accepted<ResultResponse>>(
                v => TypedResults.Accepted($"/minimal/{value}", v)));

        // Or you can directly return a Result, and let the ActionFilter automatically convert 
        // it to a ResultRespondeSuccess on success, or a ProblemDetails on error.
        group.MapDelete("{success}", (bool success, IMyService myService)
            => success ?
            Result<string>.Success("Deleted successfully") :
            Result<string>.Failure(Error.Failure("Err1", "Value must be true")))
            .WithResultsResultFilter();
    }
}